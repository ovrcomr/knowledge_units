**String updating**

<br>

A `String` can grow in size and its contents can change, just like the content of a `Vec<T>`, if we push more data
into it. In addition, we can convinienlty use the `+` operator or the `format!` macro to concatenate `String`
values.

<br>

*Appending using push_str and push*

We can grow a `String` by using the `push_str` method to append a string slice :

```rust
let mut basic_string = String::from("foo");
s.push_str("bar");
```

After these two lines, `basic_string` will contain 'foobar'. The `push_str` method takes a string slice because
we do not necessarly want to take ownership of the parameter :

```rust
let mut first_string = String::from("foo");
let second_string = "bar"; // &str
first_string.push_str(second_string); // foobar
```

If the `push_str` method took ownership of `second_string`, we would not be able to print its value on the last
line. However, this code works.

The `push` method takes a single character as a parameter and adds it to the `String` :

```rust
let mut new_string = String::from("lo");
new_string.push("l");
```

<br>

*Concatenation with + or format!*

Often, we will need to combine two existing strings. One way to do so is to use `+` :

```rust
let string_one = String::from("Hello, ");
let string_two = String::from("world!");
let sentence = string_one + &string_two; // string_one has been mooved and cannot be used anymore
```

The string `sentence` will contain 'Hello, world!'. The reason `string_one` is no longer valid after the addition,
and the reason we used reference to `string_two`, has to do with the signature of the method that is called when
we use `+`. It uses the `add` method, whose signature looks like `fn add(self, s: &str) -> String {}`.

In the standard library, you will see `add` defined using generics and associated types. Here we've
substitued in concrete types, which is what happens when we call this method with `String` values.
This signature gives us the clues we need in order to understand the tricky bits of `+`.

We only can add a `&str` to a `String`, we cannot add two `String` values together.
At first, `&second_string` is a `&String`, but in the `add` method, Rust uses a *deref coercion*, which
here turns `&second_string` into `&second_string[..]`. Because `add` does not take ownership of the
`s` parameter (parameter name in the add signature), `second_string` will still be a valid `String` after
this operation.

Second, we can see in the signature that `add` takes ownership of `self` because it does not have a `&`.
This means `string_one` will be moved into the `add` call and will no longer be valid after that.
So, although `let phrase = string_one + &string_two`; looks like it will copy both strings and create a new one,
this statement actuallt takes ownership of the result. In other words, it looks like it is making a lot of copies,
but it is not. The implementation is more efficient than copying.

If we need to concatenate multiple strings, the behvior of the `+` gets unwiedly.
At this point, for combining strings in more complicated ways, we can instead use the `format!` macro :

<br>

```rust
let string_one = String::from("tic");
let string_two = String::from("tac");
let string_three = String::from("toe");
let sentence = format!("{string_one}-{string_two}-{string_three}");
```

This code also sets `sentence` to 'tic-tac-toe'. The `format!` marco works like `println!()`, but instead of
printing the ouput to the screen, it returns a `String` with the contents. The version of the code using `format!`
is much easier to read, and the code generated by the `format!` macro uses references so that this call doesn't
take ownership of any of its parameters.
